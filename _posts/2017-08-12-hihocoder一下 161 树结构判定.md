---
layout: post
title:  hiho一下 161：树结构判定
date:   2017-08-12 17:32:01 +0800
categories: hihoCoder
tag: 刷题
---

**推荐**
------

推荐一个刷题的网站：[hihoCoder](http://hihocoder.com/hiho)

<br>
hiho一下第161周题目：树结构判定

<hr>

题目描述
====

时间限制:1000ms

单点时限:1000ms

内存限制:256MB

描述
------------------------------------

给定一个包含 N 个顶点 M 条边的无向图 G ，判断 G 是不是一棵树。

输入
------------------------------------

第一个是一个整数 T ，代表测试数据的组数。 (1 ≤ T ≤ 10)

每组测试数据第一行包含两个整数 N 和 M 。(2 ≤ N ≤ 500, 1 ≤ M ≤ 100000)

以下 M 行每行包含两个整数 a 和 b ，表示顶点 a 和顶点 b 之间有一条边。(1 ≤ a, b ≤ N)

输出
------------------------------------

对于每组数据，输出YES或者NO表示 G 是否是一棵树。

样例输入
------------------------------------

{% highlight c %}
2
3 2
3 1
3 2
5 5
3 1
3 2
4 5
1 2
4 1 
{% endhighlight %}


样例输出
------------------------------------

{% highlight c %}
YES
NO
{% endhighlight %}

<br/>

<hr>

题目实现
====================================

本题中的每个无向图有N个顶点，M条边，要求根据边的输入判定一个无向图是否为一棵树，无向图为树的充要条件是：

 - N = M + 1 
 - N个点连通

第一个条件好判断，关键是第二个条件，判断连通性一般也有两种方法：

 1. 从一个点（比如1号点）开始进行DFS/BFS，搜索过程中把遇到的点都标记上，最后检查是不是N个点都被标记了。
 2. 使用并查集，依次处理每一条边，把每条边的两个顶点都合并到一个集合里。最后检查是不是N个点都在同一个集合中。

我使用了并查集来实现，附加一个并查集讲解链接：
[并查集详解 (转)](http://blog.csdn.net/dellaserss/article/details/7724401/)
文章对并查集的讲解十分生动细致。

下面是实现代码：

{% highlight cpp %}
/*动归实现*/
#include <iostream>
#include <string>

using namespace std;

int main()
{
	int N;
	cin >> N;

	while(N--)
	{
		string str;
		cin >> str;
		int len = str.size();
		int max = 1;
		int flag[1000][1000] = {0};
		for(int i = 0; i < len; i++)
		{
			flag[i][i] = 1;
		}
		for(int i = 0; i < len - 1; i++)
		{
			if(str[i] == str[i + 1])
			{
				flag[i][i + 1] = 1;
				max = 2;
			}
		}

		for(int i = 3; i <= len; i++)
		{
			for(int j = 0; j < len - i + 1; j++)
			{
				int k = j + i - 1;
				if(str[j] == str[k] && flag[j + 1][k - 1])
				{
					flag[j][k] = 1;
					max = i;
				}
			}
		}
		cout << max << endl;
	}
}
{% endhighlight %}