---
layout: post
title:  hihocoder 1：最长回文子串
date:   2016-12-12 23:42:01 +0800
categories: 代码
tag: 刷题
---

* content
{:toc}

推荐
====================================
推荐一个刷题的网站：[hihoCoder](http://hihocoder.com/hiho)

　　这个网站每周都会更新一道有趣的算法题，还附带讲解，难度还可以。之前做过一段时间，但是随着大三开学事情变多，再加上我比较懒，，，刷题也就搁置下来了。现在突然觉得，每天刷一道醒醒脑子，可以缓解学习压力，还能不让自己不想学习的时候的没事干，并且自己也有了，每天的刷题也可以记录到博客上，这样也是十分令人开心的，好了话不多说，说干就干。这是hihocoder每周练习的第一天，打算是每天刷一道过往周的一道题，不能保证每天都能做到，因为自己实在是太懒了，有来看博客的朋友，也欢迎评论监督啦~


<br>
下面开始hihoCoder第一周的题目：最长回文字串

<hr>

题目描述
====================================

时间限制:1000ms

单点时限:1000ms

内存限制:64MB

描述
------------------------------------

　　小Hi和小Ho是一对好朋友，出生在信息化社会的他们对编程产生了莫大的兴趣，他们约定好互相帮助，在编程的学习道路上一同前进。

　　这一天，他们遇到了一连串的字符串，于是小Hi就向小Ho提出了那个经典的问题：“小Ho，你能不能分别在这些字符串中找到它们每一个的最长回文子串呢？”

　　小Ho奇怪的问道：“什么叫做最长回文子串呢？”

　　小Hi回答道：“一个字符串中连续的一段就是这个字符串的子串，而回文串指的是12421这种从前往后读和从后往前读一模一样的字符串，所以最长回文子串的意思就是这个字符串中最长的身为回文串的子串啦~”

　　小Ho道：“原来如此！那么我该怎么得到这些字符串呢？我又应该怎么告诉你我所计算出的最长回文子串呢？

　　小Hi笑着说道：“这个很容易啦，你只需要写一个程序，先从标准输入读取一个整数N（N<=30)，代表我给你的字符串的个数，然后接下来的就是我要给你的那N个字符串（字符串长度<=10^6)啦。而你要告诉我你的答案的话，只要将你计算出的最长回文子串的长度按照我给你的顺序依次输出到标准输出就可以了！”


样例输入
------------------------------------

{% highlight c %}
3
abababa
aaaabaa
acacdas
{% endhighlight %}


样例输出
------------------------------------

{% highlight c %}
7
5
3
{% endhighlight %}

<br/>

<hr>

题目实现
====================================

一、dp实现
------------------------------------

`dp的思路：`

dp的重点当然是动态转移方程，考虑一个字符串：

　　c c a a b b a a b c b

最长回文子串为 aabbaa，长度为6。

求解过程首先需要一个二维数组求解过程首先需要一个二维数组 flag[][] 记录状态，二维数组的两个索引分别为字符串中当前查询到的始字符和终字符的索引，而数组中每一个值则表示始字符到终字符之间的这段字符串是否是回文串，若是则数组值为1，若不是则为0。比如 flag[1][3]表示原字符串的1位置到3位置这一段长度为3的字符串是否是回文串，上面的那个字符串中，1位置到3位置的字符串为 caa，由于其不是一个回文串，所以数组该位置值为0，即 flag[1][3] = 0;

有了状态数组以后，我们便可以根据字符串对整个数组先进行初始数据填充，初始数据有两种，我将它们命名为“奇数回文”和“偶数回文”，奇数回文例如：

　　aba

这是一个回文串，长度为3，可以看到这个回文串的基是 b，只是一个长度为1的回文串。

双数回文例如：

　　abba

这个回文串长度为4，可以看出回文串中间的基为 bb，是一个长度为2的回文串。

定义一个记录最长回文串的int长度变量 max。

对状态数组初始化时，这两种基的情况都要考虑，首先每个字符必定和它本身成一个长度为1的回文串，故对于每一个i，初始化二维数组的flag[i][i]的值为1。max = 1，而后遍历整个字符串，判断每一个字符和它的后一个字符是否相同，如果是则说明其构成一个长度为2的回文串，则将当前位置 i 和后一个字符位置 i + 1 的数组值 flag[i][i + 1] 置为1，max = 2。

完成初始化后，我们开始正式的dp过程，使用两层循环，外层遍历 i = 3 : length，i表示后面的回文串长度，内层遍历 j = 0 : length - i，动态转移方程为：

{% highlight c %}
k = j + i - 1;
flag[j][k] = (str[j] == str[k] && flag[j + 1][k - 1]) ? 1 : 0;
max = (str[j] == str[k] && flag[j + 1][k - 1]) ? i : 0;
{% endhighlight %}

方程含义其实就是对于每一个长度i的字符串，判断除去左右两个字符后中间的字符串是否是回文串，并且判断这两端字符是否相等，如果两个条件都为真，则这个长度i的字符串也是回文串，将其对应的 flag 值更新为1，并更新max。

上面就是dp具体算法过程，实现代码如下：

{% highlight cpp %}
/*动归实现*/
#include <iostream>
#include <string>

using namespace std;

int main()
{
	int N;
	cin >> N;

	while(N--)
	{
		string str;
		cin >> str;
		int len = str.size();
		int max = 1;
		int flag[1000][1000] = {0};
		for(int i = 0; i < len; i++)
		{
			flag[i][i] = 1;
		}
		for(int i = 0; i < len - 1; i++)
		{
			if(str[i] == str[i + 1])
			{
				flag[i][i + 1] = 1;
				max = 2;
			}
		}

		for(int i = 3; i <= len; i++)
		{
			for(int j = 0; j < len - i + 1; j++)
			{
				int k = j + i - 1;
				if(str[j] == str[k] && flag[j + 1][k - 1])
				{
					flag[j][k] = 1;
					max = i;
				}
			}
		}
		cout << max << endl;
	}
}
{% endhighlight %}

dp的确可以稳定的实现，但其时间复杂度为 O(n^2)，且能够处理的字符串长度受到了状态数组的大小的限制，对于本题中要求字符串长度上限 10^6，需要定义一个 10^6 * 10^6 大小的二维数组，这个数组占用的空间是十分巨大的，显然超出了要求的空间限制，所以本题采用dp是不可取，dp仅仅作为一种算法实现方法来使用，并不能完美的解决本题。故需要考虑其他算法。

<hr>	

二、中心扩展法实现
------------------------------------

`中心扩展法思路：`

中心扩展法理解起来十分简单，即从回文串中间的位置，逐步向外扩展，因为回文串是一个对称的字符串，所以每次向中心的左和右各扩展一位，如果字符串是回文串，则扩展到的这两位应该是相等的。实现中需要遍历字符串的每一个字符，来当作中心点，然后进行左右展遍历，判断每次遍历到的字符是否相同。

当然这里也存在“奇数回文”和“偶数回文”，所以在找中心时，奇数中心和偶数中心都要考虑，需要分别对奇数和偶数中心进行扩展遍历。最后取遍历过程中取到的回文串的最大长度。

具体实现代码如下：

{% highlight cpp %}
/*中心扩展法*/
#include <iostream>
#include <string>

using namespace std;

int getLen(string str, int l, int r);
{
	int len = str.size();
	while(l >= 0 && r <= len && str[l] == str[r])
	{
		l--;
		r++;
	}
	
	return (r - l - 1);
}

int main()
{
	int N;
	cin >> N;
	
	while(N--)
	{
		string str;
		cin >> str;
		int dan = getLen(str, i, i);
		int shuang = getLen(str, i, i+1);
		max = max > dan ? max : dan;
		max = max > shuang ? max : shuang;
	}
}
{% endhighlight %}

中心扩展法的时间复杂度依然为O(n^2)，但是相比于dp，中心扩展法在空间上有了很大的优化，不用定义很大的数组去存储状态，所以相对来说，中心扩展法比dp相对更优一些。


三、Manacher算法
------------------------------------

好了，终于见到大boss了，不得不说，这个算法是真心强，这个算法就是传说中时间复杂度 O(n)的最长回文串求解算法，一起来看下它是怎么实现的：


`Manacher算法思路：`

这个算法只对“奇数回文”求解，对“偶数回文”是无法求解的，所以拿到一个字符串后，我们应该首先将它处理成一个只可能含有“奇数回文”的字符串，处理方法是在字符串的每两个字符之间插入一个平常很少用到的标志字符，比如 '#'，字符串的开头结尾也各插一个，比如字符串：

　　c c a a b b a a b c b

插入 # 后，变为：

　　# c # c # a # a # b # b # a # a # b # c # b #

这样就使得这个字符串变成了只可能存在关于'#'对称的回文串的字符串，从而实现只存在“奇数回文”。

奇数处理后，接下来到了算法的核心，算法核心是基于一个这样的思想：回文串一定是中心对称的，所以字符串中以每一个字符为中心的回文串，可能存在一个和其对称的字符，他们的回文串的情况是相同的。这两个字符是关于另一个字符中心对称的。

还考虑上面添加了 # 的字符串，最长回文子串应该是：

　　# a # a # b # b # a # a #

所以对于左边第一个 a，它和右边的最后一个 a 是对称的，所以可以进行一个初始的判断：右边的a和左边的a在这个最长回文子串内部，回文情况应该相同的。即我们需要记录这个子串最右边的边界，然后通过判断，可以得到a的初始以a为中心的回文串长度。得到初始的之后，我们以a为中心进行向外延伸，和中心扩展法类似，所以这个算法重要的地方就是在于记录每次得到的最长回文串的中心位置，以及以这个为中心的最长回文串的最右边界的位置，然后对于每一个字符 a，只要当前得到的最长回文串的内部，我们都可以找到关于这个回文串中心点对应的左边的 a'，从而可以得到一个初始回文长度，然后中心扩展便节约许多时间。

具体代码如下：

{% highlight cpp %}
/*Manacher算法，传说中的O(n)复杂度的方法*/
#include <math.h>
#include <iostream>
#include <string>

using namespace std;

int kp(string str)
{
	int i; // 当前的中心位置
	int mx = 0; // 当前遍历过的所有回文子串的最右边界。
	int id = 0; // 当前遍历过的具有最右边界的回文子串的中心位置
	int len = str.size(); // 字符串长度
	int mp[len + 1]; // mp[i]表示以第i个字符为中心的最长回文串从中心位置向右延伸的字符数。
	int max_len = 0;
	for(i = 0; i < len; i++)
	{
		mp[i] = mx > i ? min(mp[2*id - i], mp[id] + id - i) : 1;
		while(i - mp[i] >= 0 && i + mp[i] < len && str[i + mp[i]] == str[i - mp[i]])
			mp[i]++;
		if(mp[i] + i > mx)
		{
			mx = mp[i] + i;
			id = i;
			max_len = max_len < mx - id - 1 ? mx - id - 1 : max_len;
		}
	}

	return max_len;
}

string init(string str)
{
	int len = str.size();
	string res = "";
	res += '#';
	for(int i = 0; i < len; i++)
	{
		res += str[i];
		res += '#';
	}
	//res += 0;
	return res;
}

int main()
{
	int N;
	cin >> N;
	while(N--)
	{
		string str;
		cin >> str;
		str = init(str);
		cout << kp(str) << endl;
	}
}
{% endhighlight %}

总结这道题的三种方法，可以看出都能通过题中给出的样例测试用例，但是性能的差别却十分明显，在做题的过程中，掌握快速找到最优解的方法将是至关重要的。

好了今天这道题目打卡成功 ^_^




