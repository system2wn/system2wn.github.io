---
layout: post
title:  frustum pointnets处理数据说明
date:   2019-07-23 15:50:43 +0800
categories: 论文代码
tag: 论文代码
---

* content
{:toc}

# 代码数据说明

分别就KITTI数据集中的**label**和**calib**数据以及代码最终生成 **.pikkle**所用的数据进行说明。

## 一、KITTI数据

### 1. label

字段|数据含义
:-:|:-:
label[0]|目标类别，例如Car
label[1]|截断标志；0表示目标未被截断，1表示被截断
label[2]|遮挡程度；取值范围为(1,2,3,4)，0表示未被遮挡
label[3]|观察物体的角度，取值范围(-pi,pi)
label[4]|目标左上角在图像中的x坐标
label[5]|目标左上角在图像中的y坐标
label[6]|目标右下角在图像中的x坐标
label[7]|目标右上角在图像中的y坐标
label[8]|目标物体的真实高度，单位米
label[9]|目标物体的真实宽度，单位米
label[10]|目标物体的真实长度，单位米
label[11]|目标物体在3D相机坐标中位置的x坐标
label[12]|目标物体在3D相机坐标中位置的y坐标
label[13]|目标物体在3D相机坐标中位置的z坐标
label[14]|目标物体在3D相机坐标中相对于y轴的旋转角度
label[15]|score字段（没什么用）

----

### 2. Calib

**1、P0矩阵：** 没有用。

**2、P1矩阵：** 没有用。

**3、P2矩阵：** 标号为2的相机（左侧彩色相机）的内参矩阵。

**4、P3矩阵：** 标号为3的相机（右侧彩色相机）的内参矩阵。

**5、R0_rect：** 0号相机（参考相机）的矫正旋转矩阵。

**6、Tr_velo_to_cam：** 点云数据到相机的外参矩阵

在这里的0号相机（参考相机）相当于一个没有经过任何标定的原始相机，并且这个相机的坐标没有经过旋转矫正。使用Tr_velo_to_cam矩阵可以将点云三维坐标映射到0号相机（参考相机）坐标系。

0号相机坐标系需要使用R0_Rect进行旋转矫正，然后才能完成到2号相机（左侧彩色相机）的转换。

要从0号相机（参考相机）经过旋转标定后的坐标系映射到2号相机坐标系需要使用P2矩阵。

综上所述，要从点云坐标**y**转换到2号相机坐标**x**，需要先使用Tr_velo_to_cam，再R0_Rect，最后使用P2：

$$y=P2R0Rect*TrVeloToCam*x$$

要从图像坐标转换到3D相机坐标的话，需要使用相机内参矩阵。

## 二、生成.pikkle文件所用数据

1. 数据集的数据序号，如00000，000001这种。
2. 2D图像中目标的边界框，以(x_min, y_min, x_max, y_max)的形式存储。
3. 目标边界框的3D坐标，是一个8*3矩阵，包含八个顶点的xyz坐标值。
4. 矫正后的相机坐标系中的坐标点属于2D边界框映射的那些坐标点。
5. 4中对应的那些坐标点的标签，是3D目标框中的点标签为1，不是的为0。
6. 目标的类型，例如Car
7. 3D边界框的heading angle，其实就是label[14]
8. 3D边界框的长（label[10]）、宽（label[9]）、高（label[8]）
9. frustum的角度，对应prepare_date.py的第224行。