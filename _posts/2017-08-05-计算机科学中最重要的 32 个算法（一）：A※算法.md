---
layout: post
title:  计算机科学中最重要的 32 个算法（一）：A*算法
date:   2017-08-05 14:29:01 +0800
categories: C++
tag: 算法
---

前言
==
	之前就因为切题而学习过A*算法，但只是为了当时做题，大致懂了算法步骤后就直接套用了现成的代码，而没有去深入了解算法思想和具体过程，所以导致现在提起A*算法依然是一头雾水。昨天看到了一篇IT文章，评选了计算机科学中最重要的32个算法，A*算法被排在第一位，我计划将这32种算法都系统的学习一下，所以先从A*算法开始，将A*算法彻底吃透。

算法作用
====
如图所示：
<img src="{{ '/styles/images/2017-08-05-计算机科学中最重要的 32 个算法（一）：A算法/map.jpg' | prepend: site.baseurl }}" alt="map"/>

在这个简易地图中， 绿色方块的是起点 (用 A 表示), 中间蓝色的是障碍物, 红色的方块 (用 B 表示) 是目的地，为了可以用一个二维数组来表示地图, 我们将地图划分成一个个的小方块。我们想找到从A到B的一条可走路径，还希望它是最短的，这就需要用到寻路算法了。

A*算法是一种启发式的寻路算法，我们知道寻路算法有很多：递归、非递归、广度优先搜索、深度优先搜索等等，其中广度优先（BFS）和深度优先（DFS）是我们最常用的，如果说比较一下这两种算法：

1、BFS
-----
广度优先可以看成一种辐射式的搜索，每次搜索附近所有的点，直至找到目标点，这种搜索算法有两个特点：

 - 搜索到的路径一定是最优的，因为每次辐射搜索到的点都是最短距离点。
 - 算法消耗非常大，搜索速度很慢。

2、DFS
-----
深度优先可以看成是一根筋、不撞南墙不回头式的搜索，朝着一个方向不断前进，当碰到边界或者障碍物才会回溯，最终直到到达目标点，这种算法也有两个特点：

 - 算法消耗比较大，相比于BFS来说也好一些。
 - 找到的路径不一定是最优的，因为是只要找到一条路径就算最终路径。

具体的BFS和DFS过程随后可以单独写博客记录。


然后就是我们今天的主角A*算法，为什么A*算法优呢？因为A*算法在找到下一个最邻近点的时候，还有一个启发式的限制条件，那就是下一个点距离目标点的距离，这个距离的计算方法视情况而定，这样可以大大节省时间，并且找到最优的路径，下面详细介绍这个算法思想。

算法思想
====
考虑一个问题，为什么广度优先搜索可以找到最优路径？因为它每次遍历的点都是距离出发点距离最优的点，最后直到遍历到目标点，也是距离出发点距离最优的，所以最优路径也就能够找到。但是广度优先搜索很傻地遍历了地图上几乎所有的点，这也就使得它很慢，遍历所有点的原因就是它只考虑了遍历点距离出发点的距离。

而A*算法的优势在于，它不仅考虑遍历点到出发点的距离，还考虑**遍历点到目标点的估算距离。**

我们简单的抽象一下，如果用f(M)表示：从起点S到终点E（经过M点）的距离，那他就可以表示成为两段距离之和，即：S→M的距离 + M→E的距离。如果我们用符号表示的话，就可以写成：f(M) = g(M) + h(M)。如图所示：
<img src="{{ '/styles/images/2017-08-05-计算机科学中最重要的 32 个算法（一）：A算法/gM+hM.png' | prepend: site.baseurl }}" alt="gM+hM"/>

我们扩展到M点的时候，S→M的距离就已经知道，所以g(M)是已知的。但是M到E的距离我们还不知道。如果我们能用某种公式，能大概预测一下这个距离，而这个预测的值又比较精确，我们就能很精确的知道每一个即将扩展的点是否是最优的解路径上的点，这样也就很快了。

一种常用的h(M)的计算方法是：M距离终点E的横向的距离+纵向的距离。

注意：h(M)并不一定是M到E的真正距离，考虑下面这张图：
<img src="{{ '/styles/images/2017-08-05-计算机科学中最重要的 32 个算法（一）：A算法/3.png' | prepend: site.baseurl }}" alt="3"/>

就可以发现h(M)是小于M到E的真正距离的。

但是思考下，我们并不真正需要知道真正距离是什么，即使h(M)小于真正距离，也就是说，我们尽可能找那些f(M)=g(M)+h(M)小的点（其中h(M)是个估算值），当做我们的路径经过点，即使实际的h'(M)值可能和h(M)值不等也没关系，我们就当做一个参考（总比广度优先搜索好吧~）。如果通过这个估算，能干掉很多明显很差的点，我们也就节省了很多不必要的花销。

上面的知识了解后，我们还有两个问题要解决：

1、估算函数h(M)如何计算？
---------------

常见的距离计算公式有这么几种：
 
 1. 曼哈顿距离：这个名字听起来好高端，说白了，就是上面我们讲的横向格子数+纵向格子数；
 2. 欧式距离：这个名字听起来也很高端，说白了，就是两点间的直线距离sqrt((x1-x2)^2 + (y1-y2)^2)；

除了上述的距离计算公式以外，还有一些变种的距离计算公式，如：对角线距离等等。这个就在具体的问题中做具体的优化了。

2、不同估算函数对于结果的影响
---------------

距离公式选择不同，对我们的寻路结果有哪些影响呢？

 1. 当估算的距离h完全等于实际距离h'时，也就是每次扩展的那个点我们都准确的知道，如果选他以后，我们的路径距离是多少，这样我们就不用乱选了，每次都选最小的那个，一路下去，肯定就是最优的解，而且基本不用扩展其他的点。
 
 2. 如果估算距离h小于实际距离h'时，我们到最后一定能找到一条最短路径(如果存在另外一条更短的评估路径，就会选择更小的那个)，但是有可能会经过很多无效的点。极端情况，当h==0的时候，最终的距离函数就变成：
f(M)=g(M)+h(M)
=> f(M)=g(M)+0
=> f(M)=g(M)
这不就是我们的广度优先搜索算法吗！ 他只考虑和起始点的距离关系，毫无启发而言。
 
 3. 如果估算距离h大于实际距离h'时，有可能就很快找到一条通往目的地的路径，但是却不一定是最优的解。
 
因此，A*算法最后留给我们的，就是在时间和距离上需要考虑的一个平衡。如果要求最短距离，则一定选择h小于等于实际距离；如果不一定求解最优解，而是要速度快，则可以选择h大于等于实际距离。

具体实现
====
实现步骤如下：

 1. 从起点A开始，把它作为待处理的方格存入一个"开启列表"，开启列表就是一个等待检查方格的列表。

 2. 寻找起点A周围可以到达的方格，计算每个方格的F值（F=G+H），并将它们放入"开启列表"，设置它们的"父方格"为A。

 3. 从"开启列表"中删除起点 A，并将起点 A 加入"关闭列表"，"关闭列表"中存放的都是不需要再次检查的方格。
 4. 从“开启列表”中找到F值最小的那个方格C，将它从“开启列表”中删除，放入“关闭列表”。
 5. 检查第4步中得到的方格C的所有相邻并且可以到达 (障碍物和 "关闭列表" 的方格都不考虑) 的方格. 如果这些方格还不在 "开启列表" 里的话，将它们加入 "开启列表"，计算这些方格的 G, H 和 F 值各是多少，并设置它们的 "父方格" 为 C。
 6. 如果某个相邻方格 D 已经在 "开启列表" 里了，那就检查如果用新的路径 (就是经过C 的路径) 到达它的话，G值是否会更低一些：如果新的G值更低，那就把它的 "父方格" 改为目前选中的方格 C，然后重新计算并存储它的 F 值和 G 值 (H 值不需要重新计算，因为对于每个方块的H 值是不变的)；如果新的 G 值比较高，就说明经过 C 再到达 D 不是一个明智的选择，因为它需要更远的路，这时我们什么也不做。
 7. 上面的步骤不断进行，直到我们发现目标点出现在“开启列表”中，则说明我们找到了最优路径，程序停止运行。

若想找到整条路径，因为我们对每个点都记录了父节点，所以从目标点开始，遍历每个点的父节点，最终到出发点，就是完整的路径。

伪代码
===

```
把起始格添加到 "开启列表" 
do 
{ 
       寻找开启列表中F值最低的格子, 我们称它为当前格. 
       把它切换到关闭列表. 
       对当前格相邻的8格中的每一个 
          if (它不可通过 || 已经在 "关闭列表" 中) 
          { 
                什么也不做. 
           } 
          if (它不在开启列表中) 
          { 
                把它添加进 "开启列表", 把当前格作为这一格的父节点, 计算这一格的 FGH 
          if (它已经在开启列表中) 
          { 
                if (用G值为参考检查新的路径是否更好, 更低的G值意味着更好的路径) 
                    { 
                            把这一格的父节点改成当前格, 并且重新计算这一格的 GF 值. 
                    } 
} while( 目标格已经在 "开启列表", 这时候路径被找到) 
如果开启列表已经空了, 说明路径不存在.

最后从目标格开始, 沿着每一格的父节点移动直到回到起始格, 这就是路径。
```

完整代码
====


